package me.matrix4f.classcloak.util;

import jdk.internal.org.objectweb.asm.Opcodes;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.*;

import java.lang.reflect.Field;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static org.objectweb.asm.Opcodes.*;

public class BytecodeUtils {

    /**
     * The map that maps primitive type descriptors to their Java names.
     */
    public static HashMap<Character, String> primitivesNameMap = new HashMap<>();
    /**
     * The map that maps the T_TYPENAME for T_FLOAT, T_INT etc. to their equivalent descriptors.
     */
    public static HashMap<Integer, String> newarrayTypeMap = new HashMap<>();
    /**
     * The opcodes that are generated by Java if statements.
     */
    public static final int[] opcodesIf = {
            IFEQ, IFNE,
            IFLT, IFGE, IFGT, IFLE,
            IF_ICMPEQ, IF_ICMPNE,
            IF_ICMPLT, IF_ICMPGE, IF_ICMPGT, IF_ICMPLE,
            IF_ACMPEQ, IF_ACMPNE,
            IFNULL, IFNONNULL
    };
    /**
     * The opcode that can be generated by Java return statements.
     */
    public static final int[] opcodesReturn = {
            RETURN, ARETURN, IRETURN, LRETURN, DRETURN, FRETURN
    };
    /**
     * An auto-generated map that maps the numerical equivalent of an opcode to
     * its mnemonic. This is a debug-only feature that relies on reflection, so
     * it won't work in release mode.
     */
    private static Map<Integer, String> opcodeNameMap = new HashMap<>();

    static {
        //Initialize primtivesNameMap
        primitivesNameMap.put('I',"int");
        primitivesNameMap.put('F',"float");
        primitivesNameMap.put('B',"byte");
        primitivesNameMap.put('C',"char");
        primitivesNameMap.put('D',"double");
        primitivesNameMap.put('Z',"boolean");
        primitivesNameMap.put('J',"long");
        primitivesNameMap.put('S',"short");
        primitivesNameMap.put('V',"void");
        //Initialize newarrayTypeMap
        newarrayTypeMap.put(T_INT,      "I");
        newarrayTypeMap.put(T_CHAR,     "C");
        newarrayTypeMap.put(T_BOOLEAN,  "Z");
        newarrayTypeMap.put(T_BYTE,     "B");
        newarrayTypeMap.put(T_LONG,     "J");
        newarrayTypeMap.put(T_DOUBLE,   "D");
        newarrayTypeMap.put(T_SHORT,    "S");
        newarrayTypeMap.put(T_FLOAT,    "F");

        //Initialize opcodes map
        List<Field> fields = Arrays.asList(Opcodes.class.getDeclaredFields());
        Collections.reverse(fields);

        fields.stream()
                .filter(field -> !field.getName().startsWith("ACC_") && !field.getName().startsWith("V") && !field.getName().startsWith("F_") && !field.getName().startsWith("ASM") && !field.getName().startsWith("H_") && !field.getName().startsWith("T_") && field.getType() == int.class)
                .forEach(field -> {
                    try {
                        opcodeNameMap.put((Integer) field.get(null), field.getName().toLowerCase());
                    } catch (Exception e) {
                        //Ignore the fields that aren't valid
                    }
                });
    }

    /**
     * A debug method to print the opcode mnemonics of the specified nodes
     * @param nodes The instructions to be printed
     */
    public static void printOpcodes(List<AbstractInsnNode> nodes) {
        nodes.stream()
                .mapToInt(AbstractInsnNode::getOpcode)
                .mapToObj(BytecodeUtils::getOpcodeName)
                .filter(Objects::nonNull)
                .forEach(System.out::println);
    }

    /**
     * A debug method to print the opcode mnemonics of the specified nodes
     * after passing the names through a function.
     * @param nodes The instructions to be printed
     * @param mapper The function which the names will be passed through
     */
    public static void printOpcodes(List<AbstractInsnNode> nodes, Function<String, String> mapper) {
        nodes.stream()
                .mapToInt(AbstractInsnNode::getOpcode)
                .mapToObj(BytecodeUtils::getOpcodeName)
                .filter(Objects::nonNull)
                .map(mapper)
                .forEach(System.out::println);
    }

    /**
     * Returns a human-readable version of a method instruction
     * @param methodInsnNode The instruction which to interpret
     * @return An empty string if it isn't a MethodInsnNode, or a string
     * in the format com/package/Class.methodName(MethodDescriptor)ReturnType
     */
    public static String getMethodInfo(AbstractInsnNode methodInsnNode) {
        if(methodInsnNode instanceof MethodInsnNode) {
            MethodInsnNode min = (MethodInsnNode) methodInsnNode;
            return min.owner + '.' + min.name + min.desc;
        }
        return "";
    }

    /**
     * @param list The haystack in which to search
     * @param target The needle (target method) which search for
     * @return All instructions in the target instruction set that invoke the
     * target method
     */
    public static List<MethodInsnNode> getInvokers(InsnList list, String target) {
        return Stream.of(list.toArray())
                .filter(node -> doesNodeInvoke(node, target))
                .map(node -> (MethodInsnNode) node)
                .collect(Collectors.toList());
    }

    /**
     * @param node The node being compared
     * @param target The target method which to search for invokers of
     * @return Whether the target instruction node invokes the target method
     */
    public static boolean doesNodeInvoke(AbstractInsnNode node, String target) {
        if(!(node instanceof MethodInsnNode))
            return false;
        MethodInsnNode min = (MethodInsnNode) node;
        String simplified = min.owner + '.' + min.name + min.desc;
        return simplified.equals(target);
    }

    /**
     * Converts a Java List to an ASM InsnList
     * @param list The Java List
     * @return An ASM InsnList containing the same instructions as the Java List
     */
    public static InsnList toList(List<AbstractInsnNode> list) {
        InsnList insns = new InsnList();
        list.stream().filter(Objects::nonNull).forEach(insns::add);
        return insns;
    }

    /**
     * Converts an opcode number to its human-readable mnemonic
     * @param opcode The opcode number
     * @return A human-readable mnemonic
     */
    public static String getOpcodeName(int opcode) {
        return opcodeNameMap.getOrDefault(opcode, null);
    }

    /**
     * @return A map that maps a primitive type name to its corresponding descriptor
     */
    public static HashMap<String, Character> getNamePrimitivesMap() {
        HashMap<String,Character> map = new HashMap<>();
        primitivesNameMap.forEach((character, s) -> map.put(s,character));
        return map;
    }

    /**
     * Constructs a list from the specified instruction, then filters through
     * that list to obtain all labels.
     * @param node The instruction whose list's labels will be returned
     * @return A list of labels in the same InsnList as the specified node
     */
    public static List<LabelNode> getLabelsInList(AbstractInsnNode node) {
        AbstractInsnNode counter = node;
        while(counter.getPrevious() != null)
            counter = counter.getPrevious();

        List<LabelNode> list = new ArrayList<>();

        if(counter instanceof LabelNode)
            list.add((LabelNode) counter);

        while(counter.getNext() != null) {
            counter = counter.getNext();
            if(counter instanceof LabelNode)
                list.add((LabelNode) counter);
        }

        return list;
    }

    /**
     * Constructs a list of all instructions in the same list as the specified instruction
     * @param node The specified instruction
     * @return A list of all instructions in the same list as the specified instruction
     */
    public static List<AbstractInsnNode> getInsnsInList(AbstractInsnNode node) {
        AbstractInsnNode counter = node;
        while(counter.getPrevious() != null)
            counter = counter.getPrevious();

        List<AbstractInsnNode> list = new ArrayList<>();

        list.add(counter);

        while(counter.getNext() != null) {
            counter = counter.getNext();
            list.add(counter);
        }

        return list;
    }

    /**
     * @param clazz The class of the specified instruction type
     * @param method The method whose instructions will be searched
     * @param <T> The instruction class type
     * @return A stream of the MethodNode's instructions matching the specified class type
     */
    public static <T extends AbstractInsnNode> Stream<T> streamInstructions(Class<T> clazz, MethodNode method) {
        return Arrays.stream(method.instructions.toArray())
                .filter(node -> node.getClass() == clazz)
                .map(node-> (T) node);
    }

    /**
     * Allows integration between the Tree API and the Visitor API
     * by running .accept() on all instructions.
     * @param insnList The set of all instructions which will be accepted into the MethodVisitor
     * @param mv The visitor which will accept the instructions
     */
    public static void visitAll(InsnList insnList, MethodVisitor mv) {
        Arrays.stream(insnList.toArray())
                .forEach(insn -> insn.accept(mv));
    }

    /**
     * Converts a Java name to a descriptor, but doesn't have the preceding L
     * before it.
     * @param name The Java name of the type
     * @return A corresponding descriptor without a preceding L
     */
    public static String convertTypeNameToDescriptorWithoutPrecedingL(String name) {
        StringBuilder builder = new StringBuilder(name);
        int arrays = 0;
        int arrayIndex;
        while((arrayIndex = builder.indexOf("[]")) != -1) {
            builder.delete(arrayIndex, arrayIndex+2);
            arrays++;
        }
        String noArrays = builder.toString();
        Optional<Character> primitive = primitivesNameMap.entrySet()
                .stream()
                .filter(e -> e.getValue().equalsIgnoreCase(noArrays))
                .map(Map.Entry::getKey)
                .findFirst();
        StringBuilder desc = new StringBuilder();
        for(int i = 0; i < arrays; i++)
            desc.append("[");

        if(primitive.isPresent()) {
            desc.append(primitive.get());
        } else {
            desc.append(noArrays);
        }
        return desc.toString();
    }

    /**
     * @param desc The descriptor which will be converted
     * @return If the descriptor marks a primitive type, <code>null</code>, or
     * else, returns the class name in format com/mycompany/Class
     */
    public static String getInternalNameOfDescriptor(String desc) {
        desc = desc.replace("[","");
        if(desc.length() == 1)
            return null;
        return desc.substring(1,desc.length()-1);
    }

    /**
     * @param methodDesc The descriptor of the method
     * @return A list of Strings of the CLASSES used by the method descriptor.
     * Does NOT contain primitive types.
     */
    public static List<String> getInternalNamesUsedByMethodSignature(String methodDesc) {
        Type[] types = Type.getArgumentTypes(methodDesc);
        Type returnType = Type.getReturnType(methodDesc);
        List<String> internalNames = Stream.of(types)
                .map(Type::getDescriptor)
                .map(BytecodeUtils::getInternalNameOfDescriptor)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        String returnTypeName = getInternalNameOfDescriptor(returnType.getDescriptor());
        if(returnTypeName != null)
            internalNames.add(returnTypeName);
        return internalNames;
    }

    /**
     * Converts a Java name into an internal descriptor
     * @param name The Java type name
     * @return A corresponding descriptor
     */
    public static String convertTypeNameToDescriptor(String name) {
        StringBuilder builder = new StringBuilder(name);
        int arrays = 0;
        int arrayIndex;
        while((arrayIndex = builder.indexOf("[]")) != -1) {
            builder.delete(arrayIndex, arrayIndex+2);
            arrays++;
        }
        String noArrays = builder.toString().replace('.','/');
        Optional<Character> primitive = primitivesNameMap.entrySet()
                .stream()
                .filter(e -> e.getValue().equalsIgnoreCase(noArrays))
                .map(Map.Entry::getKey)
                .findFirst();
        StringBuilder desc = new StringBuilder();
        for(int i = 0; i < arrays; i++)
            desc.append("[");

        if(primitive.isPresent()) {
            desc.append(primitive.get());
        } else {
            desc.append("L").append(noArrays).append(";");
        }
        return desc.toString();
    }

    /**
     * @param javaName The Java type name
     * @return The amount of array dimensions in it.<br>
     *     Example:<br>
     *         int[][] returns 2, int[] returns 1, int returns 0
     */
    public static int getArrayDimensionsInJavaName(String javaName) {
        StringBuilder builder = new StringBuilder(javaName);
        int arrays = 0;
        int arrayIndex;
        while((arrayIndex = builder.indexOf("[]")) != -1) {
            builder.delete(arrayIndex, arrayIndex+2);
            arrays++;
        }
        return arrays;
    }

    /**
     * @param desc The type descriptor
     * @return The amount of array dimensions in it<br>
     *     Example:<br>
     *         [I returns 1, [[[Ljava/lang/Object; returns 3, J returns 0
     */
    public static int getArrayDimensionsInDescriptor(String desc) {
        int arrays = 0;
        while(desc.charAt(0) == '[') {
            desc = desc.substring(1);
            arrays++;
        }
        return arrays;
    }

    /**
     * @param cn The class node
     * @return The Java name of the class node (without slashes, but instead .s)
     */
    public static String getJavaName(ClassNode cn) {
        return cn.name.replace('/','.');
    }

    /**
     * @param desc An internal method descriptor
     * @return The java equivalent of the method descriptor, in the format:
     * (argtype1, argtype2, argtype3...)returntype
     */
    public static String convertMethodDescriptorToJava(String desc) {
        StringBuilder sb = new StringBuilder("(");
        Stream.of(Type.getArgumentTypes(desc))
                .map(Type::getDescriptor)
                .map(BytecodeUtils::convertDescriptorToJavaName)
                .forEach(s -> sb.append(s).append(", "));
        if(sb.toString().endsWith(", ")) {
            sb.deleteCharAt(sb.length() - 1);
            sb.deleteCharAt(sb.length() - 1);
        }
        sb.append(')');
        sb.append(convertDescriptorToJavaName(Type.getReturnType(desc).getDescriptor()));

        return sb.toString();
    }

    /**
     * @param desc The internal descriptor
     * @return The Java equivalent of the specified descriptor
     */
    public static String convertDescriptorToJavaName(String desc) {
        int brackets = 0;
        while(desc.charAt(0) == '[') {
            brackets++;
            desc = desc.substring(1);
        }

        String internalName;
        if(desc.charAt(desc.length()-1) == ';') internalName = desc.substring(1,desc.length()-1);
        else                                    internalName = desc;

        if (internalName.length() == 1) //primitive
            internalName = primitivesNameMap.get(internalName.charAt(0));
        else
            internalName = internalName.replace('/','.');

        for(int i = 0; i < brackets; i++)
            internalName += "[]";

        return internalName;
    }
}
